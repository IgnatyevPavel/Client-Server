# Клиент-серверная архитектура.
Клиент серверная архитектура - на этих двух словах клиент и сервер, строится практически всё айти с помощью этой архитектуры мы можем на устройстве открыть мессенджер телеграм\гугл и прочее. на пк открыть приложения которые куда то что то отправляют или откруда то что то берёт - это всё клиент серверная архитектура всё чем мы пользуемся на сегодня это приложения которые поддерживают клиент-серверную архитектуру
## что из себя может представлять клиент и сервер?

**Всё что отправляет запрос на сервер - Клиент. Сам сервер тоже может быть клиентом.**
везде где есть пользователь -  мобильное\веб-приложение\сайт в браузере\приложение на пк\ и т.д. это клиент. грубоговоря вы тыкаете пальцами в клиент, а клиент все запросы отправляет на сервер и получает от сервера ответы.
**отправляет запрос - клиент**


**Всё что приняло запрос и ответило - Сервер.**
всё куда клиент отправляет запросы по каким то сетевым протоколам это сервер, для простоты понятия
**принимант запрос - сервер**

## что может быть сервером?
есть несколько понятий сервера
+ сервер как железяка
+ дата центры - машины в больших залах, где всё гудит. место где стоит сервера, на которых по большому счёту держится весь интернет, по миру их сотни тысяч, их располагают недалеко от атомных\гидро\электро станций. чем ближе он построен, тем дешевле будет электричество. дата центры - промышленное
+ домашний пк тоже может быть сервером, так как на нём может быть запущена программа, которая принимает запросы и отправляет ответы, при правильной настройке
+ теоретически телефон тоже может быть сервером, тоже может принять запрос и отправлять ответы.
+ то есть любая железка способная принимать запрос и отправлять ответ утюг с микросхемой,умный холодильник с микросхемами с вайфаем или блютузом(если нет продуктов может заказать),
 и вам привезёт курьер товары

## Кто может отправить запрос на клиент?
это как вот то что клиент в который вы пальцами тыкаете может отправить запрос
этот запрос может отправить сервер. вот другой сервер который стоит стоит, у него что-то по таймеру щёлкнуло, он пошёл обновился и забрал информацию в другое место
отправил реквест получил респонс
и вот в момент когда он отправлял реквест он был клиентом
а тот кто получил от него реквест тот был сервером
это если в общем говорить про серверы и клиенты

в современном мире все клиенты и сервера которые связанны с обычными пользователями всё отправляет информацию по протоколу HTTPS(Hyper text transfer protokol security), раньше был HTTP (Hyper text transfer protokol) протокол передачи гипертекста, его механика, этого базового протокола состоит в том что клиент отправляет запрос, сервер получает запрос и отправляет клиенту ответ на его запроc. то есть сервер сам по себе клиенту ничего не отправит, сервер ждёт слушает интернет, скажет ему там кто-то что-то, спросят или не спросят. спросят - ответит, не спросит - не ответит. это базовая механика HTTP протокола.

предположим что все открывали в браузере сайт с формой логина, так вот как это происходит
+ вы открываете свой браузер, вбиваете туда запрос https://ksendzov.com/login_form
+ отправляете в строчке браузера такой запрос
+ запрос попадает на сервер, 
+ сервер получает запрос и отвечает на клиент формой логина
+ на этой форме будет логин и пароль с кнопкой sign in если максимально упростить
+ предположим мы с вами заполняем логин и заполняем пароль правильными данными, нажимаем кнопку сигн ин
+ после того как вы нажмете кнопку синг ин клиент отправвит запрос на сервер в котором будут перреданы данные для того чтобы залогинить пользователя
+ когда оно всё прилетает? оно прилетает в API, как оно выглядит? https://ksendzov.com/user-login это будет запросом
+ когда вы со своего клиента, вбили какой то запрос в браузере и нажали на ентер, ваш запрос по сети интернет летит  в центральный комутатор вашей страны, не важно с мобильного интернета или в вайфая с квартиры\офиса, весь интернет страны работает через центральные комутаторы, которые обслуживаются гос компании внутри страны, исключение спутники старлину, там нет ЦК, спутники как точка доступа, минуя гос сети, блокировки, прослушки и тд, его невозможно контролировать.
все запросы с клиента летят в ЦК, который связан с мировой сетью дата центров и комутаторов. весь интернет в мире это кабеля которые тянутся по дну морей, под землёй и тд.
+ весь интернет страны проходит через одну гос компанию, любого пользователя можно отследить\послушать\посмотреть что он отправлят. весь интернет можно отследить.
+ даже если включен vpn когда идёт шифровка внутреннего канала и spuffing ip конечного адреса, тут уже как служба безоп будет работать если дано указание прослушать клиента, то сб и отдел к пишет в компании которые предоставляют услуги VPN сетей с предложением сотрудничать, или вы будете заблокированы для действия на территории конкретной страны
если vpn продолжает работать на территории страны, значит всё слито в сб. зарабатывает, продаёт vpn даже там где он заблокирован. если продолжает работать - ключи шифрования сдали
компании которые не поделились ключами шифрования, те компании блокируют на ЦК. если вы не используете старлинк или спутниковый интернет. то его просматривают. власти в любой момент могут просто отключить посейшение, заблокировать конкретный ip адреса которые предоставлены организацией, которая предлагает vpn услуги, у таких компаний не бесконечное количество серверов, их счётное количество, и ничего не стоит работкику ЦК в определённый игнор файл написать список IP адресов который просто будет игнорироваться ЦК. все пользователи которые будут туда стучаться, они не получат ответов ЦК будет их резать. 
+ ваш запросик летит на ЦК
+ с ЦК улетает на DNS(domain name servises) 
вы же отправляете запросик ksendzov.com, под этим человекопонятным названием лежит такая вот штука - 22.43.121.210 это называется IP адрес. почему так сделали? потому что человек не ассоциирует свой ресурс с цифрами, а вот с буквами и словом, ассоциировать интернет ресурс вполне себе нормально, но машина коммутаторный сервер, ему надо цифры, так вот чтобы был матч цифер и слов существует DNS сервер. как раз эти DNS говорят где по какому айпишнику сидит вот этот вот ресурс ksendzov.com. DNS отвечает что ksendzov.com сидит на 22.43.121.210 и ЦК отправляет запрос на сервер ksendzov.com. всё сервер получает запрос, отправляет ответ, ответ приходит на клиент.

всё что отправляется в окошках браузера отправляется в ЦК потом в DNS и потом на сервер.
### Что значит сервер принял запрос?
кто понимает что вам ответить?
когда бэкэнд програмисты и фронтэнд програмисты пилят свою часть
бэк - сервер 
фронт-клиент
они договариваются какие кнопки, какие запросы будут отправлять бэк этнд програмисты понимаю как эти запросы принимать и что отвечать клиенту, чтобы клиент это всё понял
получается что? API (aplication program interface) это набор точек в которые можно что=то отправить и получить ответ, если отправить запрос не в эту точку, то ответа от сервера будет 404 NOT FOUND.
так вот бэк с фронтом договариваются, если с баузера прилетает запрос ksendzov.com/login form мы хотим логин форм, и то что написано бэком смотрит ksendzov.com это к нам, а login form это эндпоинт, набор точек куда клиент может что-то спросить и сервер что-то ответит, одна из точек это login form 
то есть клиент знает, в его код вписаны адреса этих точек сервера, по которым надо что=то спрашивать
login form это не случайное слово, когда вы на клиенте нажали на кнопку залогиниться эта кнопка отправляет запрос на эндпоинт login form сервер получает запрос конкретно в эндпоинт API(состоит из точек касания) сервер получает запрос в точку касания которая называется логин-форм дальше бэк прогеры знают если у нас пришёл запрос в логин форм, надо отдать форму логина. эта механика она и програмируется бэк и фронт прогерами
что значит отдать формочку логина?
фрондэндеры написали HTML CSS JS файлики которые если их правильно прочитать представляют из себя что-то человеко вразумительное понтное, куда можно тыкнуть пальцем и ввести слова
получается что сервер берёт текстовй файл JS и CSS(каскад стайл шитс) и HTML (найти перевод) это всё текст, сервер эти три файла пакует, заварачивает это всё в ответ (респонс) и отдаёт на клиент. т.е. запрос на логин форму, запаковал отправил клиенту
клиент (браузер хром, сафари, тор и т.д.) браузер получает на себя эти три файла HTML CSS JS. если человек не шарящий, откроет эти файлы, то там будет текст. никакой кнопочки куда нажать он не увидит, но чтобы он увидел эту кнопку, в браузере существует движок который принимает эти файлики, парсит(прочитывает) их понимает что там написано и на основании текста в этих 3х файлах, рисует (рендерит) человекопонятную картинку
в этих файликах описано: поле в которое можно ввести какой то текст, будет стоять вот здесь, в него будет вписан плейсхолдер - логин, пассворд(поле 2) будет распологаться здесь в него можно ввести какой то абракадабра текст, чуть ниже справа, будет располагаться кнопка сигн ин будет срабатывать валидация правильности введённых данных, и если данные введены правильно, то отправляется запрос уже по другому эндпоинту юзер-логин на наш сервер в эндпоинт юзер-огин, здесь у нас поинт логин форм, а тут юзер логин, бэк принимает этот запрос он видит что ему постучали в апи в эндпоиню юзер-логин, значит в теле этого запроса должны лежать логин и пароль пользователя, эта логика написана заранее, бэк с фронтом договорились. вы нам логин и пасс отправляйте в эндпоинт юзер логин в json формате. бэк пишут у себя в апи открывают эндпоинт юзер логин и они знаю что если пришёл запрос в этот эндпоинт то в бади должны быть логин и пароль, то либо падает сервер, 500 либо на клиент, нету логина и пароля,
дальше сервер принимает этот логин и пароль, провалидировал и идём в базу данных, 
## что делает база данных?
она хранит. 
наш сервер спрашивает у базы. база, вот такой логин в тебе есть? база - есть. сервер - хорошо. мы прошли **идентификацию.(вопрос с обеседования.)**
когда мы проверили что существует  логин в базе это была идентификация.

теперь сервер спрашивает, а пароль к этому логину такой? тот ли юзер, тот ли логин у нас был тогда зарегистрирован,
база - да есть, это именно тот самый кто у нас тогда регистрировался, это его пароль, это прошла 
**аутентификацция** - подтверждена аутентичность, уникальность этого поьзователя в нашей системе

сервер спрашивает, раз всё есть дай мне его личные данные, дальше идёт обработка к каким данным пользователь имеет доступ, если он относится к группе обычных клиентов, то он имеет доступ только к своим данным, его личным данным - это была **авторизация** проверка на доступную информацию, проверка прав доступа, к чему клиент имеет право прикоснуться. к чему не может.
база ответила
сервер - запакуй всю его личную информацию, он как залогиненый пользователь захочет лазить по сайту, давай выдадем ему токен ключ сервер сохраняет себе токен ключ и вместе с одданой информацией от базы пакует всё это в HTML CSS JS и токен, и отправляет клиенту
браузер парсит полученное, пользователь видит и может взаимодействовать с интерфейсом - это что касается двухуровневой клиент - серверной архитекторуой сервер первый уровень, база данных второй уровень.

### сервер может спрашивать информацию не только у базы данных но и у других серверов web service 
когда серверу необходимо спросить доп. информацию. допустим информацию о выдаче кредита по этому данному пресонажу. сервер банка не хранит информацию о судимости, но он может спросить информацию у сервера мвд и в этот момент наш сервер становиться клиентом, который у сервера мвд спрашивает информацию о судимостях этого конкретного субьекто, человека. ему сервер отвечает судимостей алиментов нет и дел по непогашенным кредитам тоже нет. у банка возрастает скоринговый бал. и говорит слушай норм чел давай дадим ему кредит
хорошо
вот так оно и работает
так вот когда ещё получается какой то веб сервис, ещё какой то  есть third party сервис, можете частенько услышать такое слово third - третья сторона то это трёхуровневая клиеент-серверная архитектура или многоуровневая клиент-серверная архитектура. здесь как повезёт, смотря с кем общаться
знайте, другие веб сервися с внешней стороны не с серверов нашей компании, а просто дополнительный сервис откуда мы берём информацию это third party сервис.
ещё немного метафор про понимание.
изобретение общей клиент-серверной архитектуры - это база, это основа

# про ip про доменное имя API и клиент-серверную
все мы с вами живём в каких то зданиях, ну или стараемся жить в зданиях, так вот чтобы мы с вами могли таксисту или по карте найти нужное нам здание, нам надо в голове знать держать, помнить адрес, конкретного здания, допустим этот адрес, это улица свободы 4, мы такие ага улица свободы 4, понятно, где то я это помню, надо посмотреть на карте ага вот эта точка вот это здание. и мы уже такие идём до ул. свободы 4 и ксендзов.ком это словестные обозначения циферных данных, цифровых данных. у каждого здания в городе, вообще любого здания на територии государства, есть кадастровый номер и кадастровый реестр это в свою очередь DNS(domain name service) к которому если спросить, а вот это вот цифорка по какому адресу находиться, или вот этот адрес у него какая цифра, и там есть циферная комбинация в кадастровом реестре. но вам же не хочется запоминать кадастровый номер, проще запомнить улю свободы 4. 

мы нашли наш дом ул свободы 4. когда мы его видим прям перед собой это здание. мы же не будем в стену идти, чтобы зайти в это здание. нет мы так не сделаем, мы будем искать вход в это здание. входы внутри здания это падьезды или парадные. в айтишке это называется порт. если у вас айпи 22.33.44.55:5001 то вот 5001 это порт по которому можно в это здание зайти, по которому можно в этот сервер постучаться

нашли падьезд. подходим к двери падьезда, там есть домофон. домофон и набор квартиры это API вы просто в порт если будете стучаться 
нажимаете номер квартиры, конкретный эндпоинт - номер квартиры

ещё одна интерпритация API - вождение автомобился
вы клиент - водитель
руль, переключение передач, газ, тормоз, сцепление, магнитола, дворники и т.д. все функции - это API это интерфейс управления вашим автомобилем, что Login form или user-login. то в машине это будет сцепление и газ. а двигатель топливная система, аккумуляторы, фильтра, бортовой компьютер - это всё бэкэнд
и с помощью руля и прочих рычажков управляете этим бэкендом. ну или ещё одна интерпритация api это кофе или ресторан. вот вы пришли в ресторан вы сели, вам подают меню. меню оно и на сайте называется меню
и вот вы официанту говорите, мне пожалуйста вот это. официант такой, есть принял.
вы сидите за столиком - клиент
официант - API
кухня - бэкенд, вы как привило бэка не видите
официант приносит блюдо 

# в чём разница 
клиент сервисная архитектура и микросервисная архитектура?

веб сервисы это те же сервера, но с распределёнными обязанностями, кто то отвечает за хранение, валидацию, передачу данных в базу отвечает за спрашивание где-то на стороне, какой- то информации
на веб сервисах, большой наш сервер разбит на маленькие сервачки, которые выполняют его функции. т.е. оно либо написано монолитно, когда большой сервер за всё отвечает. либо написана микросервисная архитектура, где у каждого сервера свой выделенный функционал. либо гибрид есть и монолит и вынесено на микросервися, смотря как програмисты напилят. у каждого микросервиса есть айпишник порт своё апи такие же сервера, просто с урезанным функционалом относительно большого монолита 

# что такое токен пользователя?
уникальный ключ
строчка которая содержит текст цдзулцзопз34шег2049гк203шое2 аброкадабра данных, является уникальным кодом, сервер отдаёт этот уникальный код и клиент дальше по запросикам где пользователь должен быть залогинен. сервер каждый раз спрашивает токен у клиента. не будет пропуска тебя никуда не пустят. по этому пропуску ещё надо понимать где ты можешь быть, где нет
и если токен сгорает, то сервер режет его у себя и как только ты приходишь спрашивать со своим уже сгоревшем на сервере ключиком, сервер скажет ещё раз клиент логинься, и посмотрим что ты там хочешь.

# толстый тонкий клиент
тонкий - клиент который не несёт на себе основной функциональности в плане обработки данных, хранения данных, тонкие клиенты не несут

толстый клиент - несёт этот функционал, хранит данные, мозно их обрабатывает, сдаёт передаёт, толстый клиент - пример игры типо танчики, вов, контра, то что много чего делает на машине пользования. 

трейдинговые платформы - много информации обрабатывается, хранится это толстый клиент

тонкий - это лендинг сайт
толстый - онлайн игры

цк - полувоенная структура, туда не просто попасть
тор что делает? 
спрашиваешь сайт через тор, тор перед тем как отправить запрос на центральный комутатор, он его зашифровывает, на ЦК прилетает зашифрованная абракадабра. но там будет инфа о сервере, куда улетит запрос, сервер - впн тора, прокси сервер тора, на него пирлетает запрос, сервер смотрит куда на самом деле должен идти запрос, сервак отправляет запрос на целевой сервер, сервер отвечает, тор впн прокси получает ответ от сервера, зашифровывает и отправляет на ЦК твой страны чтобы дошло до тебя
тор браузер расшифровывает информацию и показывает человекопонятную картинку.
снифинг возможен? возможен если будет ключ шифрования и дешефровки

# бывает ли сервер без базы данных?
конвертор валют
он берёт данные от криптобиржи, данные с фиатной биржи и отправляет их тебе у себя их не хранит
рабочие файлы не считаются базой данных
что считается базой данных?

# что входит в апи? - эндпоинты

# как идёт запрос до сервера?
+ вначале запрос посылается с клиента, допустим это мы вбили в поисковую строку что-то
+ запрос пошёл на наш роутер
+ от нашего роутера запрос пошёл в центральный комутатор государства всего интернета по стране
+ центральный коммутатор спрашивает у DNS. какой IP у данного домена?
+ DNS отвечает центральному коммутатору под какие IP адресом находится сервер с запрошенным доменным именем
+ и центральный коммутатор посылает запрос на IP адрес нужного сервера, запрос приходит на API 
+ у API есть эндпоинты(точка касания) которая определяется как "/" - по умолчанию  ksendzov.com
+ сервер ответит всем контентом с сайта на центральный коммутатор
+ ответ с ЦК на роутер
+ с роутера на браузер
### ответ с сервера это текстовые данные с сервера 
+ фронтенд прогеры написали код, который надо забрать и передать на клиент когда он стучиться на определённый эндпоинт, этот код запаковывается в ответ клиенту и отправляется на клиент. Т.Е. на сервере хранятся HTML CSS JS файлы сайта, который запрашиваем 

### потом это прилетает на клиент
браузер файлы HTML CSS и JS переваривает через свой движок, который создан чтобы парсить(прочитывать) файлы которые в него сервер пришлёт

HTML() - показывает что и где должно быть расположено на сайте
CSS(каскадная таблица стилей) - 
JS()

# какой порт у HTTPS по умолчанию? - 443
# какой порт у HTTP по умолчанию? - 80
# у одного сервера может быть 65535 портов
Количество портов, которые может иметь один сервер, ограничено 65,535. Это число определяется 16-битным полем порта в стандартном протоколе передачи данных TCP/IP.

Порты делятся на две категории: зарегистрированные порты и эфемерные (или привилегированные) порты. Зарегистрированные порты (от 1 до 1023) зарезервированы для известных служб и протоколов, таких как HTTP (порт 80), FTP (порты 20 и 21), SSH (порт 22) и т.д.

Эфемерные порты (от 1024 до 65535) используются динамически и назначаются операционной системой для обслуживания различных сетевых соединений. Они обычно используются клиентскими приложениями для установки исходящих соединений с серверами на зарегистрированных портах.

Важно отметить, что не каждый порт может быть открыт на сервере, так как некоторые из них могут быть заняты операционной системой или другими службами, работающими на сервере.

и на каждом порту может быть только один сервер
то есть каждый сервер может использовать только один порт
если нам надо чтобы на одном сервере работало несколько портов, значит на одном айпишнике запускаем несколько виртуальных http серверов и у каждого будет свой порт
на одном айпишнике запущено 4 сервера и у каждого свой порт, не может быть такого что 2 сервера используют один порт

как только мы поняли какой порт, нам надо понять в какой эндпоинт нам можно постучаться, если эндпоинт правильный значит дверь откроется и мы поднимемся на нужный этаж то есть эндпоинты в апи это как квартиры и по каждому эндпоинту у вас будет какая то своя реакция системы, реакция сервера, если вы спросили действительный эедпоин вас пригласят в квартиру. если вы спросили эндпоинт по которому вам ничего не должны ответить то будет молчание
если будет эндпоинт где вас не знают, то вас не пустят. какой то ответ вы всё равно получите

так же можно обьяснить апи через машину, и через официанта
вебсервисы - отдельно стоящие сервера у которых есть свой порт, своё айпи у каждого есть своя API. но по большому счёту это такой же сервак (вебсервер) который общается с другими веб серверами, не на прямую с клиентом, а с другими веб серверами. это называется ве сервисы. то что общается с клиентом - сервер


в европейских странах могут прийти домой и выписать штраф при скачивании пиратского контента

# логика логина человека на сайте
+ спрашиваем ksendziv.com\login-form, запрос полетел(роутер-цк-днс-сервер) в эндпоинт
+ фронт и бэк договорились что при запросе в эндпоинт \login-form сервер отдаёт HTML+CSS+JS файлы формочки логина
+ и мы получаем к себе на клиент форму логина
+ в этой форме мы заполняем логин\пасс жмём кнопку sign in
+ при нажатии на кнопку sign in программисты прописали что после нажатия запрос уходит в другой эндпоинт ksendzov.com\login-user
+ на сервере бэкенд програмисты написали такой код- запросы в эндпоинт \login-user должны приходить методом POST т.е. логин\пароль должны лежать в теле запроса, не в URL и желательно в JSON
+ бэкенд скрипт на сервере лезет в тело запроса, забирает от туда логин\пароль. если есть валидация, проверяет данные на безопасность
+ сервер идёт в базу посмотреть есть ли такой пользователь или нет
+ БД ответила что есть **идентификация пройдена**
+ сервер идёт в базу данных спросить такой ли пароль у этого пользователя 
+ БД пошла сверила хэш, "да, такой" **аутинтификация** проверка аутентичности
+ сервер идёт в базу за личной информацией пользователя, для захода на его главную страницу пользователя
+ база пособирала что нужно по первому протоколу (по правилу что мы отображаем для обычных пользователей) **авторизация**
+ отдала ответ на сервер
+ сервер создаст уникальный токен для конкретного пользователя(сессионный токен). сервер держит в себе список этих уникальных сессионных ключей, сессионный ключ не может повторяться. т.е. на сервер одновременно могут залогиниться тысячи пользователей и сервер каждому пользователю будет отдавать его сессионный токен
+ сервер сгенерировал и отдал парось
+ сервер запаковал информацию в JSON. собрал HTML CSS JSскрипты и этот пакет данных отправил на клиент
+ если клиент захочет получить информацию (например детализацию платежей) нажал на кнопу эндпоинта \detals-pay
+ сервер понимает что по эндпоинту \detals-pay может перейти только залогиненный пользователь и при этом и каждом последующем запросе будет смотреть на токен(сессионный ключ), соответствует ли он или нет, кто вообще спрашивает? чтобы получить соответствующую информацию, имеет он это право или нет? сервер идёт в список сессионных ключей, спрашивает есть ли такой сессионный ключ или нет. и ему допустим NOsql база висящая в памяти реддис или монго отвечает, что да этот пользователь существует.
+ сервер подтвердил личность, что клиент залогиненный, идёт в базу данных спрашивает по этому логину историю транзакций
+ база отдаёт историю транзакция по конкретному клиенту
+ сервер отвечает клиенту историей его транзакций 
срок жизни сессионного ключа 2-3 минуты в банковском приложении, если нет никаких запросов чтобы сверить данный ключ, то он истекает и клиенту прилетает опять форма логина(для безопасности клиента)

# если на собеседовании спросят сколько уровней в архитектуре то при ответе укажите согласно какой книге, какого автора вы думаете вот так, ответ должен на что то опираться, на какой то источник знаний

железяка без софта сервером никогда не будет являться
вероятнее всего ОС сервера - линукс
на этой операционной системе устанавливается и запускается HTTP сервер. чтобы работать по протоколу HTTP
tcp\ip osi
DNS - карты 
ksendzov.com - адрес дома
123.24.65.89 - кадастровый номер дома
\login-form - квартира

123.24.65.89:443 - ip+port = soket

прежде чем лезть в DNS браузер спросит у себя в кэше есть ли у него связка этого доменного имени с ip если мы когда-то заходили на этот сайт. если в кэше браузера информация нашлась, тобраузер отправляет запрос сразу на тот ip адрес напрямую на сервер. если не нашёл то пойдёт в папку hosts. если там не найдёт то посмотрит в кэш ОС. в последнюю очередь браузер смотрит на роутере, если эти хранилища пустые, отправляется запрос в DNS
как и в жизни, если вы там уже были, то вы в последнюю очередь будете смотреть это место по карте



DNS- похоже на книгу адресов:
DN:|IP:|
|:-|-:|
|ksendzov.com|99.86.56.23
amazon.com |200.199.242.56
google.com|98.75.32.100

у каждого ресурса интернет есть свой порт
ресурс точно будет доступен по 443 порту
если говорим за http - 83 порт

благодаря API клиент и сервер могут общаться

интерфейс - панель управления. организация элементов управления в человекопонятном виде. то через что можно взаимодействовать с программой

микросервисы и монолит
монолит если упадёт, то выключится всё
если упадёт микросервис выключится только часть функционала. и в случае с микросервисом мы защищаем логику сервера от внешнего доступа

чем веб-сервис отличается от веб-сервера
веб сервер общается с клиентом
веб-сервис общается с веб-сервером и другим веб-сервисом

# Devtools
открывает сайт, жмём f12 и с помощью devtools мы можем помочь разработчику быстрее рабобраться где баг и пофиксить его
можем сделать скриншот и указать div class в баг репорте
как правило фронтендерам хватает скрина
вкладка elements - больше полезна версальщикам которые верстают внешнюю сторону сайта

toogle device toolbar
с помощью выбора девайса мы можем тестировать различное отображение нашего сайта 
можно проверить верстку сайта на различной диагонали 
выбирает shou rules
выбираем show media reqeries
с помощью ползунка справой части меняем ширину и смотрим как отрабатывает сайт
с помощью media reqeries видим breakpoints и там где рисочка контент может меняться, на них обязательно будет что-то происходить
обязательно прокручиваем вниз, смотрим как сайт отрабатывает
responsive это отзывчивая вёрстка, когда вы изменяете ширину и дизайн вёрстка сайта меняется шажками. тестирование - медленно тянем и смотрим как перестроится  
если вёрстка адаптивная - адаптируется к разрешению -  то сайт меняется по бреакпоинтам оно изменяется от одного к другому. тестирование - тянем до бреакпоинта 
когда оформляем баг обязательно указываем разрешение экрана 

смена девайса во вкладке dimensions.
включили и сразу разрешение например iphone 12 pro 
если нужен кастомные девайс внизу его можно добавить через edit можем вставить user agent и выбрать разрешение экрана и выбрать touch или klick 

**"User Agent"** (или "агент пользователя") – это строка, которую веб-браузеры или другие клиентские приложения отправляют серверу для идентификации себя. Она часто используется в интернете для обеспечения совместимости браузера со специфичными сайтами.

Строка User Agent обычно включает информацию о браузере (например, Google Chrome, Firefox, Safari), об операционной системе (Windows, Mac, Android, iOS и т.д.) и о других деталях, таких как версия браузера и дополнительных плагинов.

Благодаря этой информации серверы могут определить, как лучше представить свое содержимое для конкретных браузеров или устройств. Например, если сайт видит, что User Agent указывает на мобильный браузер, то он может автоматически переключиться на свою мобильную версию.

разработчики могут проверять по узер агенту какой пользователь заходит
и если собирается информация с какого user agent чаще всего заходят на твой сайт то можно запросить её и проверить самые частые девайсы и тестить на них приоритетно, если нет
смотришь регион, смотришь какие девайсы больше всего в ходу, добавляеь эти девайсы и проверяешь их 

если мы возьмём мобильный девайс то мы можем менять ориентацию экрана 


так же там можно выбрать троттлинг интернета - низкая скорость интернета

можно сделать capture screenshot видимой части экрана 
и capture screenshot full size 

Вкладка console для тестировщика полезная вкладка в ней могут отображаться баги 
если мы нашли страницу с багом мы можем так же прикрепить информацию с вкладки console жмём save as сохраняем логи 
в console обращайте внимание на error 404 

вкладка sourses
здесь храняться скрипты и картинки которые нужны для обработки сайта 

вкладка network это снифер трафика просматривается информация которая отправляется на сервак и которая получается от сервера 
есть вкладки что конкретно можно отфильтровать all\fetch\xhr\js\css\img\media\font(шрифты)\doc\ws(web socket - один раз отправляете запрос на сервер а дальше он на ваш клиент быдет слать информацию непрерывно\wasm\manifwst\other
что может случиться с веб сокетом? может не затереться файл js и тогда возможно что-то будет не работать 

посмотреть какие headers отправились если надо
посмотреть какую то json можно её посмотреть во вкладке prewiev  
для быстрого поиска ctrl + ф



вкладка aplication 
там будут storage используется для просмотра token сессионные ключ
в каких хранилищах можно их найти? local storage\ session storage\ cookies\
пример, зачем это надо, при обновлении страница может не обновляться, если почистить куки страница обновляется 

вкладка lighthouse оценивает производительность сайта 

через настройки во вкладке тротлинг можно настроить свой 
во вкладке location можно подставить свою локацию

какие вкладки нужно тестировщику знать:
вкладка elements 
как тестировать с мобилы
console\читать текст который пишется в консоль
sourses - не нужно
network - как снифер трафика который показывает что улетело что прилетело 

в режиме инкогнито всегда пустые куки
и если надо посмотреть как пофиксилась вёрстка 
открываете в режиме инкогнито сайт 

devtool в брауезере firefox 
session storage - sessionID
devtools очень схожи с хромом 
через firefox можно подменить тело запроса как в charles и fidler

xrv отличается session storage local storage и cookies 

что мы увидим если кнопка не будет кликабельна?
- в devtools скорее всего не будет указан a class в которой есть href ( на неё не повешано ни ссылки ни javascript и всё ты кликаешь а браузер не переходит )

# VPN

VPN расшифровывается как "Virtual Private Network". На русский язык это переводится как "виртуальная частная сеть". VPN - это технология, которая обеспечивает безопасное и анонимное соединение с интернетом, позволяя скрыть ваш IP-адрес и шифровать интернет-трафик для обеспечения приватности и безопасности в сети.

шифрование данных по своим протоколам безопасности и сеть proxy серверов 
proxy сервер может являться частью vpn либо самостоятельной единицей 
данные через proxy тоже можно слать но это будет без шифрования 
vpn - сеть которая предоставляет шифрование данных и proxy сервера через которые можно послать данные 

central comutation - это государственный фильтр 
все провайдеры покупают трафик у центрального коммутатора 

расшифровать vpn сеть без согласия vpn сети невозможно, можно но долго
поскольку ключи шифрования отдельно лежат на клиенте и трафик шифруется на клиенте, ключи дешифровки лежат на серверах и никуда не передаются 
ключи шифрование и vpn сети не передаются они зашиты в клиент и то их достать там практически нереально, они сами зашифрованы 

если клиент vpn прости обновиться его лучше обновить так как там меняют ключи шифрования

если в hard time vpn продолжает работать и не блокируется 
его ip proxy не попадают в цк значит договор есть

vpn хранят журналы посейщений на каждого пользователя 
если эта информация хранится значит к ней можно получить доступ 
понять пишется ваша история или не пишется - невозможно

starlink - спутниковая сввязь с интернетом 

если нужно постучаться на сервер компании
например jira может располагаться на серверах компании 

CDN (content delivery network)

# https протокол
- браузеры не блокируют
- гугл не понижает в выдаче 
ssl протокол и tls сертификат 
hendshake 
когда вы постучались с клиента на сервер 
сервер отправляет tls сертификат 
получаете сертификат (ключ расшифровки)
вы отправляете запрос(я сертификат получил, давай данные)
сервер отправляет зашифрованные данные tls сертификатом 
зашифрованные данные нашим сертификатом, летят по сети, прилетают на клиент
на клиенте уже есть этот протокол, согласно этому протоколу безопасности расшифровываются данные там есть ключи расшифровки всё и вы видите мой сайт ксендзов точка com так вот 

все ли помнят что такое атака man in the middle
это когда между вами и сервером кто-то внедряется и перехватывает ваш hendshake(ssl сертификат) и перехватив этот ssl сертификат его поняв прочитав и дальше отправив вам на клиент
можно дальше читать ваш зашифрованный https трафик. достаточно только встроется между нами и сервером
а кто встроен между нами и сервером? центральный коммутатор



![VPNproxy](VPNproxy.JPG)

прокси сервер - сервер(узел\сервис) в сети через который пропускается траффик 
при использовании vpn
при отправке запроса шифруется не только https, каким то своим
летит на wifi роутер 
потом на центральный коммутатор 
и на центральном коммутаторе происходит подмена ip сервера 
трафик попадает на vpn proxy server 
ip adress 0-255.0-255.0-255.0-255
proxy server расшифровывает данные, посылает их на тот сайт куда мы хотим зайти, и эти данные шифрует и передаёт нам 

